# coding=UTF-8
# ex:ts=4:sw=4:et=on

import logging
logger = logging.getLogger(__name__)

from PySide6.QtWidgets import QComboBox
from .basic import QtAdapter


class ComboBoxAdapter(QtAdapter):
    """
    Adapter for QComboBox widgets.
    Requires the property to have a 'choices' dict of {key: description}.
    """
    widget_types = ["option_list"]
    _check_widget_type = QComboBox
    _signal = "currentIndexChanged"

    def _parse_prop(self, prop, model):
        prop, model = super()._parse_prop(prop, model)
        if not isinstance(prop.choices, dict):
            raise ValueError(
                "ComboBoxAdapter requires a property with a 'choices' dict!")
        self._keys = list(prop.choices.keys())
        return prop, model

    def _connect_widget(self):
        # Populate the combo box from choices
        self._widget.clear()
        prop_choices = self._prop.choices
        for key, description in prop_choices.items():
            self._widget.addItem(str(description), userData=key)
        super()._connect_widget()

    def _prop_write(self, index):
        """Convert combo index → property key."""
        if index is not None and 0 <= index < len(self._keys):
            return self._keys[index]
        return None

    def _prop_read(self, val):
        """Convert property value → combo index."""
        try:
            return self._keys.index(val)
        except (ValueError, AttributeError):
            return 0

    _wid_read = lambda c, w: w.currentIndex()
    _wid_write = lambda c, w, v: w.setCurrentIndex(int(v) if v is not None else 0)

    def disconnect(self, model=None, widget=None):
        if self._widget is not None:
            self._widget.clear()
        super().disconnect(model=model, widget=widget)

    pass  # end of class
