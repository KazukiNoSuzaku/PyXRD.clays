# coding=UTF-8
# ex:ts=4:sw=4:et=on

import logging
logger = logging.getLogger(__name__)

from contextlib import contextmanager
from ...adapters.model_adapter import ModelAdapter
from ...support.utils import not_none


class QtAdapter(ModelAdapter):
    """Base class for PySide6 widget adapters."""
    toolkit = "qt"

    _wid_read = None
    _wid_write = None
    _signal = None        # Qt signal name as string, e.g. "textChanged"
    _signal_args = []
    _check_widget_type = None

    def __init__(self, controller, prop, widget,
            prop_read=None, prop_write=None,
            value_error=None, spurious=False,
            wid_read=None, wid_write=None,
            signal=None, signal_args=None, update=True):
        super(QtAdapter, self).__init__(
            controller, prop, widget,
            prop_read=prop_read, prop_write=prop_write,
            value_error=value_error, spurious=spurious
        )
        self._wid_read = not_none(wid_read, self._wid_read)
        self._wid_write = not_none(wid_write, self._wid_write)
        self._signal = not_none(signal, self._signal)
        self._signal_args = not_none(signal_args, self._signal_args)
        self._update = update

        if self._check_widget_type is not None:
            if not isinstance(widget, self._check_widget_type):
                raise TypeError(
                    "Property '%s' from model '%s' requires widget type %s, "
                    "got %s" % (prop.label, controller.model,
                                self._check_widget_type, type(widget))
                )
        self._connect_widget()

    # ------------------------------------------------------------------
    #  Widget connecting & disconnecting
    # ------------------------------------------------------------------
    def _connect_widget(self):
        if self._signal:
            signal_obj = getattr(self._widget, self._signal, None)
            if signal_obj is None:
                logger.error("Widget %s has no signal '%s'" % (
                    self._widget, self._signal))
            else:
                try:
                    signal_obj.connect(self._on_wid_changed)
                except Exception:
                    logger.error("Failed to connect signal '%s' on %s" % (
                        self._signal, self._widget))
                    raise
        if self._update:
            self.update_widget()

    def _on_wid_changed(self, *args):
        """Called when the Qt widget emits its change signal."""
        if self._ignoring_notifs:
            return
        self.update_model()

    def _disconnect_widget(self, widget=None):
        if self._signal is not None:
            widget = not_none(self._widget, widget)
            if widget is not None:
                signal_obj = getattr(widget, self._signal, None)
                if signal_obj is not None:
                    try:
                        signal_obj.disconnect(self._on_wid_changed)
                    except Exception:
                        pass  # already disconnected
            self._signal = None

    # ------------------------------------------------------------------
    #  Widget-side reading and writing
    # ------------------------------------------------------------------
    @contextmanager
    def _block_widget_signal(self):
        """Block all signals on the widget while writing to prevent loops."""
        self._widget.blockSignals(True)
        try:
            yield
        finally:
            self._widget.blockSignals(False)

    def _read_widget(self):
        return self._wid_read(self._widget)

    def _write_widget(self, val):
        with self._ignore_notifications():
            with self._block_widget_signal():
                return self._wid_write(self._widget, val)

    @staticmethod
    def static_to_class(func):
        def wrapper(c, *args, **kwargs):
            return func(*args, **kwargs)
        return wrapper

    pass  # end of class
