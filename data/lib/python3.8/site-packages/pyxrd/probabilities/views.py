# coding=UTF-8
# ex:ts=4:sw=4:et=on

# Copyright (c) 2013, Mathijs Dumon
# All rights reserved.
# Complete license can be found in the LICENSE file.

import os as _os
_resource_filename = lambda path: _os.path.normpath(
    _os.path.join(_os.path.dirname(_os.path.abspath(__file__)), path))
resource_filename = lambda _n, path: _resource_filename(path)

from PySide6.QtWidgets import (
    QWidget, QLabel, QCheckBox, QGridLayout, QVBoxLayout,
)
from PySide6.QtCore import Qt

from mvc.adapters.qt_support.widgets import QtScaleEntry
from mvc.support.utils import rec_getattr

from pyxrd.generic.views import BaseView, HasChildView
from pyxrd.probabilities.models import RGbounds


def get_correct_probability_views(probability, parent_view):
    """
    Convenience function that creates both an ``IndependentsView`` and
    ``MatrixView`` based on the probability model passed.
    """
    if probability is not None:
        G = probability.G
        R = probability.R
        rank = probability.rank
        if (RGbounds[R, G - 1] > 0):
            return (
                IndependentsView(meta=probability.Meta, parent=parent_view),
                MatrixView(R=R, G=G, rank=rank, parent=parent_view)
            )
        else:
            raise ValueError(
                "Cannot (yet) handle R%d for %d layer structures!" % (R, G))


class EditProbabilitiesView(HasChildView, BaseView):
    """
    Container view containing one ``MatrixView`` and one ``IndependentsView``.
    """
    builder = resource_filename(__name__, "ui/probabilities.ui")
    top = "edit_probabilities"

    independents_container = "independents_box"
    independents_view = None
    dependents_container = "dependents_box"
    dependents_view = None

    widget_format = "prob_%s"

    def set_views(self, independents_view, dependents_view):
        self.independents_view = independents_view
        self._add_child_view(
            independents_view.get_top_widget(),
            self[self.independents_container]
        )
        self.dependents_view = dependents_view
        self._add_child_view(
            dependents_view.get_top_widget(),
            self[self.dependents_container]
        )
        self.show_all()
        return self.independents_view, self.dependents_view


class ProbabilityViewMixin():
    """
    Mixin class providing interface code for controllers of both
    ``MatrixView`` and ``IndependentsView``.
    """
    def update_matrices(self, W, P):
        raise NotImplementedError


class IndependentsView(HasChildView, ProbabilityViewMixin, BaseView):
    """
    Generic view that generates a two-column list of inputs and labels using
    the model's Meta class (passed to the constructor).
    """
    builder = resource_filename(__name__, "ui/R0_independents.ui")
    top = "R0independents_box"

    lbl_widget = "lbl_independents"
    sep_widget = "seperator_i"

    widget_format = "prob_%s"

    def __init__(self, meta, **kwargs):
        assert meta is not None, "IndependentsView needs a model's Meta class!"
        BaseView.__init__(self, **kwargs)

        self.props = [
            prop for prop in meta.all_properties
            if getattr(prop, "is_independent", False)
        ]
        all_props = {prop.label: prop for prop in meta.all_properties}

        N = len(self.props)

        def create_inputs(grid_widget):
            layout = grid_widget.layout()
            if layout is None:
                layout = QGridLayout(grid_widget)
                layout.setContentsMargins(0, 0, 0, 0)
                layout.setHorizontalSpacing(2)
                layout.setVerticalSpacing(2)

            input_widgets = [None] * N
            check_widgets = [None] * N
            num_columns = 2
            column_width = 3   # label | checkbox | scale_entry per column

            for i, prop in enumerate(self.props):
                new_lbl = self.create_mathtext_widget(prop.math_title, prop.label)

                new_inp = QtScaleEntry(
                    lower=prop.minimum, upper=prop.maximum,
                    enforce_range=True
                )
                new_inp.setToolTip(prop.title)
                new_inp.setObjectName(self.widget_format % prop.label)
                self[self.widget_format % prop.label] = new_inp
                input_widgets[i] = new_inp

                col_base = (i % num_columns) * column_width
                row = int(i / num_columns)

                layout.addWidget(new_lbl, row, col_base + 0)
                layout.addWidget(new_inp, row, col_base + 2)

                if prop.inheritable is not None:
                    inh_prop = all_props.get(prop.inherit_flag, None)
                    if inh_prop is None:
                        raise ValueError(
                            "The inherit flag property `%s` is missing for "
                            "`%s` on meta model with store id `%s`" % (
                                prop.inherit_flag, prop.label, meta.store_id))

                    new_check = QCheckBox("")
                    new_check.setToolTip(inh_prop.title)
                    new_check.setObjectName(self.widget_format % inh_prop.label)
                    new_check.setEnabled(False)
                    self[self.widget_format % inh_prop.label] = new_check
                    check_widgets[i] = new_check
                    layout.addWidget(new_check, row, col_base + 1)

            return input_widgets, check_widgets

        self.i_box = self['i_box']

        num_rows = int((N + 1) / 2)
        if num_rows != 0:
            self.i_table = QWidget()
            QGridLayout(self.i_table)
            self.i_inputs, self.i_checks = create_inputs(self.i_table)
        else:
            self.i_inputs, self.i_checks = [], []

        if len(self.i_inputs) == 0:
            self[self.lbl_widget].setVisible(False)
            self[self.sep_widget].setVisible(False)
        else:
            self._add_child_view(self.i_table, self.i_box)

    def update_matrices(self, model):
        for i, (inp, check) in enumerate(zip(self.i_inputs, self.i_checks)):
            prop = self.props[i]
            inp.setValue(getattr(model, prop.label))
            if prop.inherit_flag is not None:
                inh_from = rec_getattr(model, prop.inherit_flag, None)
                check.setEnabled(inh_from is not None)
                inh_value = getattr(model, prop.inherit_flag)
                check.setChecked(inh_value)
                inp.setEnabled(not inh_value)
            elif check is not None:
                check.setEnabled(False)

    pass  # end of class


class MatrixView(HasChildView, ProbabilityViewMixin, BaseView):
    """
    Generic view that generates and updates a P and W 'matrix' table with
    labels having correct tooltips.  Can be used for any combination of
    R, G and rank.
    """
    builder = resource_filename(__name__, "ui/matrix.ui")
    top = "base_matrix_table"

    def __init__(self, R, G, rank, **kwargs):
        BaseView.__init__(self, **kwargs)
        assert rank == (G ** max(R, 1))
        self.create_matrices(R, G, rank)

    def create_matrices(self, R, G, rank):
        lR = max(R, 1)
        mod = [0] * lR
        for i in range(lR):
            mod[i] = rank / (G ** (i + 1))
        title_indeces = "".join([chr(105 + i) for i in range(lR + 1)])

        def create_labels(rank, table_widget, current_lR, fmt,
                          tooltip=lambda x, y, lR, fmt: ""):
            layout = QGridLayout(table_widget)
            layout.setContentsMargins(0, 0, 0, 0)
            layout.setHorizontalSpacing(5)
            layout.setVerticalSpacing(5)
            labels = [[None] * rank for _ in range(rank)]
            for x in range(rank):
                for y in range(rank):
                    new_lbl = QLabel("")
                    tip = tooltip(x, y, current_lR, fmt)
                    new_lbl.setToolTip(tip)
                    new_lbl.setAlignment(Qt.AlignCenter)
                    layout.addWidget(new_lbl, x, y)
                    labels[x][y] = new_lbl
            return labels

        def diagonal_tooltips(x, y, current_lR, fmt):
            if x == y:
                indeces = [0] * current_lR
                for i in range(current_lR):
                    indeces[i] = (int(x / mod[i + (lR - current_lR)]) % G) + 1
                return fmt % tuple(indeces)
            return "-"

        def subdiagonal_tooltips(x, y, current_lR, fmt):
            rowsuf = [0] * current_lR
            colsuf = [0] * current_lR
            for i in range(current_lR):
                rowsuf[i] = (int(x / mod[i + (lR - current_lR)]) % G) + 1
                colsuf[i] = (int(y / mod[i + (lR - current_lR)]) % G) + 1
            visible = all(rowsuf[i + 1] == colsuf[i] for i in range(current_lR - 1))
            if visible:
                return fmt % (tuple(rowsuf) + (colsuf[-1],))
            return "-"

        self.w_tables = []
        self.w_labels = []
        self.w_titles = []
        self.w_valids = []

        self.p_tables = []
        self.p_labels = []
        self.p_titles = []
        self.p_valids = []

        def setup_everything(tables, titles, valids, labels, title,
                             rank, current_lR, lbl_fmt, tooltips):
            w_widget = QWidget()
            tables.append(w_widget)
            titles.append(title)
            valids.append("")
            labels.append(create_labels(rank, w_widget, current_lR, lbl_fmt, tooltips))

        for current_lR in range(1, lR + 1):
            cur_rank = G ** current_lR

            setup_everything(
                self.w_tables, self.w_titles, self.w_valids, self.w_labels,
                "<b>W<sub>" + title_indeces[:current_lR] + "</sub></b>",
                cur_rank, current_lR,
                "W<sub>" + "%d" * current_lR + "</sub>",
                diagonal_tooltips
            )

            setup_everything(
                self.p_tables, self.p_titles, self.p_valids, self.p_labels,
                "<b>P<sub>" + title_indeces[:current_lR + 1] + "</sub></b>",
                cur_rank, current_lR,
                "P<sub>" + "%d" * (current_lR + 1) + "</sub>",
                subdiagonal_tooltips
            )

        # Add one extra W matrix
        setup_everything(
            self.w_tables, self.w_titles, self.w_valids, self.w_labels,
            "<b>W<sub>" + title_indeces + "</sub></b>",
            G ** lR, lR,
            "W<sub>" + "%d" * (lR + 1) + "</sub>",
            subdiagonal_tooltips
        )

        self.show_w_matrix(len(self.w_tables) - 2)
        self.show_p_matrix(len(self.p_tables) - 1)

    def update_matrices(self, model):
        lW, lP = model.get_all_matrices()

        def update_matrix(matrix, labels, mask=None):
            shape = matrix.shape
            for i in range(shape[0]):
                for j in range(shape[1]):
                    if mask is not None:
                        fgcol = "#AA0000" if mask[i, j] < 1 else "#00AA00"
                    else:
                        fgcol = "#000000"
                    text = (
                        "<small><span style='color:%s'>%.3f</span></small>"
                        % (fgcol, matrix[i, j])
                    )
                    labels[i][j].setText(text)

        for i, W in enumerate(lW):
            update_matrix(W, self.w_labels[i], model.W_valid_mask[i])
            fgcol, msg = ("#00AA00", "valid") if model.W_valid[i] else ("#AA0000", "invalid")
            self.w_valids[i] = (
                "<small><span style='color:%s'>%s</span></small>" % (fgcol, msg))
            self["lbl_W_valid"].setText(self.w_valids[i])
        for i, P in enumerate(lP):
            update_matrix(P, self.p_labels[i], model.P_valid_mask[i])
            fgcol, msg = ("#00AA00", "valid") if model.P_valid[i] else ("#AA0000", "invalid")
            self.p_valids[i] = (
                "<small><span style='color:%s'>%s</span></small>" % (fgcol, msg))
            self["lbl_P_valid"].setText(self.p_valids[i])

    def show_w_matrix(self, index):
        index = max(min(index, len(self.w_tables) - 1), 0)
        self._add_child_view(self.w_tables[index], self['w_box'])
        self["lbl_W_title"].setText(self.w_titles[index])
        self["lbl_W_valid"].setText(self.w_valids[index])
        self.show_all()
        return index

    def show_p_matrix(self, index):
        index = max(min(index, len(self.p_tables) - 1), 0)
        self._add_child_view(self.p_tables[index], self['p_box'])
        self["lbl_P_title"].setText(self.p_titles[index])
        self["lbl_P_valid"].setText(self.p_valids[index] if self.p_valids else "")
        self.show_all()
        return index

    pass  # end of class
