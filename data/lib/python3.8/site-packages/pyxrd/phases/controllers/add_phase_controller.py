# coding=UTF-8
# ex:ts=4:sw=4:et=on

# Copyright (c) 2013, Mathijs Dumon
# All rights reserved.
# Complete license can be found in the LICENSE file.

import logging
logger = logging.getLogger(__name__)

from PySide6.QtCore import Qt
from PySide6.QtWidgets import QApplication

from mvc.adapters.qt_support.treemodels.utils import create_treestore_from_directory

from pyxrd.data import settings

from pyxrd.generic.controllers import DialogController

from pyxrd.probabilities.models import get_Gbounds_for_R, get_Rbounds_for_G

class AddPhaseController(DialogController):
    """
        Controller for the add phase dialog
    """

    auto_adapt = False

    def __init__(self, model=None, view=None, parent=None, callback=None):
        super(AddPhaseController, self).__init__(
            model=model, view=view, parent=parent)
        self.callback = callback

    def register_view(self, view):
        self.update_bounds()
        self.generate_combo()

    def register_adapters(self):
        pass  # has no model intel!

    def update_R_bounds(self):
        if self.view is not None:
            min_R, max_R, R = get_Rbounds_for_G(
                self.view.get_G(), self.view.get_R())
            adj_R = self.view["adj_R"]
            if adj_R is not None:
                adj_R.setMaximum(max_R)
                adj_R.setMinimum(min_R)
            r_spin = self.view["R"]
            if r_spin is not None:
                r_spin.setValue(R)

    def update_G_bounds(self):
        if self.view is not None:
            min_G, max_G, G = get_Gbounds_for_R(
                self.view.get_R(), self.view.get_G())
            adj_G = self.view["adj_G"]
            if adj_G is not None:
                adj_G.setMaximum(max_G)
                adj_G.setMinimum(min_G)
            g_spin = self.view["G"]
            if g_spin is not None:
                g_spin.setValue(G)

    def update_bounds(self):
        self.update_G_bounds()
        self.update_R_bounds()

    def generate_combo(self):
        self.reload_combo_model()

    def reload_combo_model(self):
        combo = self.view.phase_combo_box
        if combo is None:
            return
        cmb_model = create_treestore_from_directory(
            settings.DATA_REG.get_directory_path("DEFAULT_PHASES"))
        combo.setModel(cmb_model)

    # ------------------------------------------------------------
    #      Signal handlers
    # ------------------------------------------------------------
    def on_btn_ok_clicked(self, event=None):
        self.view.hide()
        self.callback(
            self.view.get_phase_type(), self.view.get_G(), self.view.get_R())
        return True

    def on_rdb_toggled(self, widget=None):
        self.view.update_sensitivities()

    def on_btn_generate_phases_clicked(self, event=None):
        from pyxrd.scripts.generate_default_phases import run

        def ui_callback(progress):
            prog_bar = self.view["gen_progress_bar"]
            if prog_bar is not None:
                prog_bar.setValue(int(progress * 100))
            QApplication.processEvents()

        img_repeat = self.view["img_repeat"]
        gen_spinner = self.view["gen_spinner"]
        gen_progress_bar = self.view["gen_progress_bar"]

        if img_repeat is not None:
            img_repeat.setVisible(False)
        if gen_spinner is not None:
            gen_spinner.setVisible(True)
        if gen_progress_bar is not None:
            gen_progress_bar.setVisible(True)
        QApplication.processEvents()

        run(ui_callback=ui_callback)

        if gen_progress_bar is not None:
            gen_progress_bar.setVisible(False)
        if img_repeat is not None:
            img_repeat.setVisible(True)
        if gen_spinner is not None:
            gen_spinner.setVisible(False)
        self.reload_combo_model()
        return True

    def on_r_value_changed(self, *args):
        self.update_G_bounds()
        return True

    def on_g_value_changed(self, *args):
        self.update_R_bounds()
        return True

    def on_keypress(self, widget, event):
        key = event.key() if hasattr(event, 'key') else None
        if key == Qt.Key_Escape:
            self.view.hide()
            return True
        if key in (Qt.Key_Return, Qt.Key_Enter):
            self.view.hide()
            self.callback(
                self.view.get_phase_type(), self.view.get_G(), self.view.get_R())
            return True

    def on_window_edit_dialog_delete_event(self, event=None, args=None):
        self.view.hide()
        return True  # do not propagate

    pass  # end of class
