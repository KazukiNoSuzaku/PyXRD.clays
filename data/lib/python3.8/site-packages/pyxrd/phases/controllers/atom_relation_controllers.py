# coding=UTF-8
# ex:ts=4:sw=4:et=on

# Copyright (c) 2013, Mathijs Dumon
# All rights reserved.
# Complete license can be found in the LICENSE file.

import logging
logger = logging.getLogger(__name__)

from PySide6.QtCore import Qt, QStringListModel
from PySide6.QtWidgets import QApplication

from pyxrd.generic.views.treeview_tools import (
    new_text_column,
    new_pb_column,
    new_combo_column,
    create_float_data_func,
    setup_treeview
)
from pyxrd.generic.views import InlineObjectListStoreView
from pyxrd.generic.controllers import (
    DialogController,
    InlineObjectListStoreController,
    BaseController,
)

from pyxrd.phases.views import EditAtomRatioView, EditAtomContentsView
from pyxrd.phases.models.atom_relations import AtomRelation, AtomRatio, AtomContents, AtomContentObject

class AtomComboMixin(object):

    extra_props = []
    custom_handler_names = []

    def reset_combo_box(self, name):
        if self.model.component is not None:
            # Get store (list of (obj, prop, label) tuples), reset combo
            entries = self.model.create_prop_store(self.extra_props)
            combo = self.view[self.view.widget_format % name]
            if combo is None:
                return None, None
            combo.blockSignals(True)
            combo.clear()
            for obj, prop, lbl in entries:
                display_lbl = lbl(obj) if callable(lbl) else lbl
                combo.addItem(display_lbl, userData=(obj, prop))

            # Set the selected item to active:
            current_val = getattr(self.model, name)
            if current_val is not None:
                try:
                    search = (current_val[0], current_val[1])
                    for i in range(combo.count()):
                        data = combo.itemData(i)
                        if data is not None and (data[0], data[1]) == search:
                            combo.setCurrentIndex(i)
                            break
                except (IndexError, TypeError):
                    pass
            combo.blockSignals(False)
            return combo, entries
        else:
            return None, None

    @staticmethod
    def custom_handler(controller, prop, prefix):
        if prop.label in controller.custom_handler_names:
            combo, entries = controller.reset_combo_box(prop.label)

            if combo is not None and entries is not None:
                def on_changed(idx):
                    if idx >= 0:
                        data = combo.itemData(idx)
                        if data is not None:
                            setattr(controller.model,
                                    getattr(combo, 'model_prop', prop.label),
                                    list(data))
                setattr(combo, 'model_prop', prop.label)
                combo.currentIndexChanged.connect(on_changed)

                def on_item_changed(*args):
                    controller.reset_combo_box(prop.label)

                if controller.is_observing_method("atoms_changed", on_item_changed):
                    controller.remove_observing_method("atoms_changed", on_item_changed)
                controller.observe(on_item_changed, "atoms_changed", signal=True)

        else:
            return False
        return True

    pass  # end of class

class EditUnitCellPropertyController(BaseController, AtomComboMixin):
    """
        Controller for the UnitCellProperty models (a and b cell lengths)
    """

    custom_handler_names = ["prop", ]
    widget_handlers = {
        'combo': 'custom_handler',
    }

    def __init__(self, extra_props, **kwargs):
        super(EditUnitCellPropertyController, self).__init__(**kwargs)
        self.extra_props = extra_props

    def register_adapters(self):
        BaseController.register_adapters(self)
        self.update_sensitivities()

    def update_sensitivities(self):
        ucp_value = self.view['ucp_value']
        box_enabled = self.view['box_enabled']
        if ucp_value is not None:
            ucp_value.setEnabled(not self.model.enabled)
        if box_enabled is not None:
            box_enabled.setEnabled(self.model.enabled)

    # ------------------------------------------------------------
    #      Notifications of observable properties
    # ------------------------------------------------------------
    @BaseController.observe("enabled", assign=True)
    def notif_enabled_changed(self, model, prop_name, info):
        self.update_sensitivities()

    pass  # end of class

class EditAtomRatioController(DialogController, AtomComboMixin):
    """
        Controller for the atom ratio edit dialog
    """
    custom_handler_names = ["atom1", "atom2"]
    widget_handlers = {
        'custom': 'custom_handler',
    }

    pass  # end of class

class EditAtomContentsController(DialogController):
    """
        Controller for the atom contents edit dialog
    """

    auto_adapt_excluded = [
        "atom_contents",
    ]

    contents_list_view = None
    contents_list_controller = None

    def __init__(self, *args, **kwargs):
        super(EditAtomContentsController, self).__init__(*args, **kwargs)
        # Create atom contents controller:
        self.contents_list_view = InlineObjectListStoreView(parent=self.view)
        self.contents_list_controller = ContentsListController(
            "atom_contents", model=self.model,
            view=self.contents_list_view, parent=self)
        # Set subview:
        self.view.set_contents_list_view(self.contents_list_view.get_top_widget())

    pass  # end of class

class ContentsListController(InlineObjectListStoreController):
    """
        Controller for the atom contents ListStore
    """
    new_val = None
    auto_adapt = False

    treemodel_class_type = AtomContentObject

    def _reset_treeview(self, tv, model):
        setup_treeview(tv, model, sel_mode='MULTIPLE', reset=True)
        tv.setModel(model)

        # Build a string-list model for the atom combo column
        self.combo_entries = self.model.create_prop_store() if self.model is not None else []
        combo_names = []
        for obj, prop, lbl in self.combo_entries:
            display = lbl(obj) if callable(lbl) else lbl
            combo_names.append(display)
        self.combo_names_model = QStringListModel(combo_names)

        def atom_renderer(column, cell, model, itr, *args):
            if hasattr(itr, 'row'):  # QModelIndex
                from PySide6.QtCore import Qt as _Qt
                obj = model.data(model.index(itr.row(), 0), _Qt.UserRole)
            else:
                obj = model.get_value(itr, 0) if hasattr(model, 'get_value') else None
            if obj is not None and hasattr(obj, "name"):
                try:
                    cell.set_property('text', obj.name)
                except Exception:
                    cell._rendered_text = obj.name
            else:
                try:
                    cell.set_property('text', '#NA#')
                except Exception:
                    cell._rendered_text = '#NA#'

        tv.append_column(new_combo_column(
            "Atoms",
            data_func=atom_renderer,
            changed_callback=self.on_atom_changed,
            edited_callback=self.on_atom_edited,
            xalign=0.0,
            expand=False,
            has_entry=False,
            model=self.combo_names_model,
            text_column=0,
            editable=True))

        # Content column:
        def on_float_edited(rend, path, new_text, col):
            if hasattr(model, 'get_iter'):
                itr = model.get_iter(path)
                try:
                    model.set_value(itr, col, float(new_text))
                except ValueError:
                    logger.exception("Invalid value entered ('%s')!" % new_text)
            return True
        tv.append_column(new_text_column(
            'Default contents', text_col=2, xalign=0.0,
            editable=True,
            data_func=create_float_data_func(),
            edited_callback=(on_float_edited, (2,))))

    def _setup_treeview(self, tv, model):
        self._reset_treeview(tv, model)

    def __init__(self, treemodel_property_name, **kwargs):
        super(ContentsListController, self).__init__(
            treemodel_property_name=treemodel_property_name,
            enable_import=False, enable_export=False, **kwargs
        )

    def create_new_object_proxy(self):
        return AtomContentObject(None, None, 1.0)

    def on_atom_changed(self, combo, path, new_iter):
        # Map from combo_names_model index to combo_entries index
        if hasattr(new_iter, 'row'):
            row = new_iter.row()
        else:
            try:
                row = int(str(new_iter))
            except (ValueError, TypeError):
                row = -1
        if 0 <= row < len(self.combo_entries):
            obj, prop, _ = self.combo_entries[row]
            self.new_val = (obj, prop)

    def on_atom_edited(self, combo, path, new_text, model=None):
        if self.new_val:
            new_atom, new_prop = self.new_val
            self.model.set_atom_content_values(path, new_atom, new_prop)
            self.new_val = None
        return True


    pass  # end of class

class EditAtomRelationsController(InlineObjectListStoreController):
    """
        Controller for the components' atom relations ObjectListStore
    """
    file_filters = AtomRelation.Meta.file_filters
    auto_adapt = False
    treemodel_class_type = AtomRelation

    add_types = [
        ("Ratio", AtomRatio, EditAtomRatioView, EditAtomRatioController),
        ("Contents", AtomContents, EditAtomContentsView, EditAtomContentsController),
    ]

    def _reset_treeview(self, tv, model):
        setup_treeview(tv, model, sel_mode='MULTIPLE', reset=True)
        tv.setModel(model)

        # Name column:
        def text_renderer(column, cell, model, itr, args=None):
            if hasattr(itr, 'row'):
                from PySide6.QtCore import Qt as _Qt
                driven = model.data(
                    model.index(itr.row(), model.c_driven_by_other), _Qt.DisplayRole)
            else:
                driven = model.get_value(itr, model.c_driven_by_other) if hasattr(model, 'get_value') else False
            editable = not bool(driven)
            # In Qt, set style via font:
            try:
                cell.set_property('editable', editable)
                from PySide6.QtGui import QFont
                font = QFont()
                font.setItalic(bool(driven))
                cell.set_property('font', font)
            except Exception:
                pass
        col = new_text_column(
            'Name',
            data_func=text_renderer,
            editable=True,
            edited_callback=(self.on_item_cell_edited, (model, model.c_name)),
            resizable=False,
            text_col=model.c_name)
        setattr(col, "col_descr", 'Name')
        tv.append_column(col)

        # Value of the relation:
        float_rend = create_float_data_func()
        def data_renderer(column, cell, model, itr, args=None):
            text_renderer(column, cell, model, itr, args)
            float_rend(column, cell, model, itr, args)
        col = new_text_column(
            'Value',
            data_func=data_renderer,
            editable=True,
            edited_callback=(self.on_item_cell_edited, (model, model.c_value)),
            resizable=False,
            text_col=model.c_value)
        setattr(col, "col_descr", 'Value')
        tv.append_column(col)

        # Up, down and edit arrows:
        def setup_image_button(image, colnr):
            col = new_pb_column(" ", resizable=False, expand=False, stock_id=image)
            setattr(col, "col_descr", colnr)
            tv.append_column(col)
        setup_image_button("213-up-arrow", "Up")
        setup_image_button("212-down-arrow", "Down")
        setup_image_button("030-pencil", "Edit")

    def _setup_treeview(self, tv, model):
        tv.clicked.connect(lambda idx: self.tv_button_press(tv, idx))
        self._reset_treeview(tv, model)

    def __init__(self, **kwargs):
        super(EditAtomRelationsController, self).__init__(
            enable_import=False, enable_export=False, **kwargs)

    def create_new_object_proxy(self):
        return self.add_type(parent=self.model)

    def tv_button_press(self, tv, index):
        if not index.isValid():
            return
        model = tv.model()
        relation = index.internalPointer()
        if relation is None and hasattr(model, 'get_object'):
            relation = model.get_object(index)

        # Check which column was clicked
        cols = getattr(tv, '_pyxrd_columns', [])
        col_idx = index.column()
        col = cols[col_idx] if col_idx < len(cols) else None
        column = getattr(col, "col_descr", None) if col is not None else None

        if relation is not None:
            if column == "Edit":
                self._edit_item(relation)
            elif column == "Up":
                self.model.move_atom_relation_up(relation)
            elif column == "Down":
                self.model.move_atom_relation_down(relation)

    pass  # end of class
