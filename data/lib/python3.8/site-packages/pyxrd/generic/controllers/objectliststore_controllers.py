# coding=UTF-8
# ex:ts=4:sw=4:et=on

# Copyright (c) 2013, Mathijs Dumon
# All rights reserved.
# Complete license can be found in the LICENSE file.

from contextlib import contextmanager

from PySide6.QtCore import QItemSelectionModel

from mvc.adapters.qt_support.tree_view_adapters import wrap_list_property_to_treemodel
from mvc.adapters.qt_support.dialogs.dialog_factory import DialogFactory

from pyxrd.generic.utils import not_none
from pyxrd.generic.views.treeview_tools import new_text_column, setup_treeview

from .base_controller import BaseController
from .dialog_controller import DialogController


class TreeModelMixin(object):
    """
        A mixin providing functionality to get a TreeModel property from a model.
        If that property is an actual TreeModel, it will use it directly.
        Otherwise it will first wrap it in an ObjectListStore
    """

    treemodel_getter_format = "get_%s_tree_model"

    treemodel_property_name = ""
    treemodel_class_type = None

    _treemodel = None
    @property
    def treemodel(self):
        self._update_treemodel_property()
        return self._treemodel

    @property
    def treemodel_data(self):
        if getattr(self, "model", None) is not None:
            return getattr(self.model, self.treemodel_property_name, None)
        else:
            return None

    def __init__(self, treemodel_property_name=None, treemodel_class_type=None, *args, **kwargs):
        super(TreeModelMixin, self).__init__(*args, **kwargs)
        self.treemodel_property_name = not_none(treemodel_property_name, self.treemodel_property_name)
        self.treemodel_class_type = not_none(treemodel_class_type, self.treemodel_class_type)

    def _update_treemodel_property(self):
        if getattr(self, "model", None) is not None:
            self._treemodel = wrap_list_property_to_treemodel(
                self.model,
                getattr(type(self.model), self.treemodel_property_name)
            )


class TreeViewMixin(object):
    """
        Mixin that provides some generic methods to access or set the objects selected in a treeview.
    """

    def get_selected_object(self, tv):
        # call this implementation, not the overriden method:
        objects = TreeViewMixin.get_selected_objects(self, tv)
        if objects is not None and len(objects) == 1:
            return objects[0]
        return None

    def get_selected_objects(self, tv):
        sm = tv.selectionModel()
        if sm is None:
            return None
        idxs = [idx for idx in sm.selectedIndexes() if idx.column() == 0]
        if not idxs:
            return None
        model = tv.model()
        objects = []
        for idx in idxs:
            obj = idx.internalPointer()
            if obj is None and hasattr(model, 'get_object'):
                obj = model.get_object(idx)
            if obj is not None:
                objects.append(obj)
        return objects if objects else None

    def get_selected_paths(self, tv):
        sm = tv.selectionModel()
        if sm is None:
            return None
        rows = [idx.row() for idx in sm.selectedIndexes() if idx.column() == 0]
        return rows if rows else None

    def get_all_objects(self, tv):
        model = tv.model()
        if model is None:
            return []
        if hasattr(model, '_data'):
            return model._data
        if hasattr(model, 'iter_objects'):
            return list(model.iter_objects())
        return []

    def set_selected_paths(self, tv, paths):
        sm = tv.selectionModel()
        sm.clearSelection()
        model = tv.model()
        for path in paths:
            idx = model.index(path, 0)
            if idx.isValid():
                sm.select(idx, QItemSelectionModel.Select | QItemSelectionModel.Rows)


class TreeControllerMixin(TreeViewMixin, TreeModelMixin):
    """
        Mixin that can be used for regular ObjectListStoreControllers (two-pane view).

        Attributes:
            model_property_name: the property name in the model corresponding to
             the ObjectListStore
            multi_selection: whether or not to allow multiple items to be selected
            columns: a list of tuples (name, column index or name) detailing which
             columns should be added to the TreeView. If a column name is passed,
             it is translated to the corresponding index.
             By default a text column is added, for custom setups you can define
             a custom method name according to this format: setup_treeview_col_name_%s
             Replace the %s with the column name you specified in this list.
            delete_msg: the default message to display when a user wants to delete one or more items.
            obj_type_map: a list of three-tuples (object type, view type, controller type)
             used to create the controller and view for editing a selected object.
    """

    multi_selection = True
    columns = [ ("Object name", 0) ]
    delete_msg = "Deleting objects is irreversible!\nAre You sure you want to continue?"
    obj_type_map = [] # list of three-tuples (object type, view type, controller type)

    _edit_controller = None
    _edit_view = None

    def __init__(self, *args, **kwargs):
        self.multi_selection = kwargs.pop("multi_selection", True)
        self.columns = kwargs.pop("columns", self.columns)
        self.delete_msg = kwargs.pop("delete_msg", self.delete_msg)

        super(TreeControllerMixin, self).__init__(*args, **kwargs)

    __row_signal_ids = None
    def _update_treemodel_property(self):
        # If we've connected to a treemodel before, clean up first:
        if self.__row_signal_ids is not None:
            old_treemodel, = self.__row_signal_ids
            try:
                old_treemodel.rowsRemoved.disconnect(self.on_item_removed)
                old_treemodel.rowsInserted.disconnect(self.on_item_inserted)
            except RuntimeError:
                pass
            self.__row_signal_ids = None
        # If the new treemodel is set, connect it up:
        if getattr(self, "model", None) is not None:
            super(TreeControllerMixin, self)._update_treemodel_property()
            # Use private _treemodel attribute, otherwise we get infinite recursions
            self._treemodel.rowsRemoved.connect(self.on_item_removed)
            self._treemodel.rowsInserted.connect(self.on_item_inserted)
            self.__row_signal_ids = (self._treemodel,)


    def get_new_edit_view(self, obj):
        """
            Gets a new 'edit object' view for the given obj, view and parent
            view. Default implementation loops over the `obj_type_map` attribute
            until it encounters a match.
        """
        if obj == None:
            return self.view.none_view
        else:
            for obj_tp, view_tp, ctrl_tp in self.obj_type_map: # @UnusedVariable
                if isinstance(obj, obj_tp):
                    return view_tp(parent=self.view)
            raise NotImplementedError("Unsupported object type %s; subclasses of"
                " TreeControllerMixin need to define an obj_type_map attribute!" % obj)

    def get_new_edit_controller(self, obj, view, parent=None):
        """
            Gets a new 'edit object' controller for the given obj, view and parent
            controller. Default implementation loops over the `obj_type_map` attribute
            until it encounters a match.
        """
        if obj == None:
            return None
        else:
            for obj_tp, view_tp, ctrl_tp in self.obj_type_map: # @UnusedVariable
                if isinstance(obj, obj_tp):
                    return ctrl_tp(model=obj, view=view, parent=parent)
            raise NotImplementedError("Unsupported object type; subclasses of"
                " TreeControllerMixin need to define an obj_type_map attribute!")

    def edit_object(self, obj):
        self._edit_view = self.view.set_edit_view(self.get_new_edit_view(obj))
        self._edit_controller = self.get_new_edit_controller(obj, self._edit_view, parent=self.parent)
        self._edit_view.show()
        return True

    def register_adapters(self):
        # connects the treeview to the treemodel
        self.setup_treeview(self.view.treeview)
        # we can now edit 'nothing':
        self.view.set_selection_state(None)
        self.edit_object(None)

    def setup_treeview(self, tv):
        """
            Sets up the treeview with columns based on the columns-tuple passed
            to the __init__ or set in the class definition.
            Subclasses can override either this method completely or provide
            custom column creation code on a per-column basis.
            To do this, create a method for e.g. column with colnr = 2:
            def setup_treeview_col_2(self, treeview, name, col_descr, col_index, tv_col_nr):
                ...
            If a string description of the column number was given, e.g. for the
            column c_name the definition should be:
            def setup_treeview_col_c_name(self, treeview, name, col_descr, col_index, tv_col_nr):
                ...

            The method should return True upon success or False otherwise.
        """
        sel_mode = 'MULTIPLE' if self.multi_selection else 'SINGLE'
        setup_treeview(
            tv, self.treemodel,
            sel_mode=sel_mode,
            on_selection_changed=self.objects_tv_selection_changed)
        tv.setModel(self.treemodel)

        # reset:
        for col in tv.get_columns():
            tv.remove_column(col)

        # add columns
        for tv_col_nr, (name, col_descr) in enumerate(self.columns):
            try:
                col_index = int(col_descr)
            except:
                col_index = getattr(self.treemodel, str(col_descr), col_descr)

            handled = False
            if hasattr(self, "setup_treeview_col_%s" % str(col_descr)):
                handler = getattr(self, "setup_treeview_col_%s" % str(col_descr))
                if callable(handler):
                    handled = handler(tv, name, col_descr, col_index, tv_col_nr)
            # custom handler failed or not present, default text column:
            if not handled:
                tv.append_column(new_text_column(
                    name, text_col=col_index,
                    resizable=(tv_col_nr == 0),
                    expand=(tv_col_nr == 0),
                    xalign=0.0 if tv_col_nr == 0 else 0.5))

        return True

    def get_selected_index(self):
        cur_obj = self.get_selected_object()
        if cur_obj is not None:
            return self.treemodel_data.index(cur_obj)
        else:
            return None

    def get_selected_object(self):
        return super(TreeControllerMixin, self).get_selected_object(self.view.treeview)

    def get_selected_objects(self):
        return super(TreeControllerMixin, self).get_selected_objects(self.view.treeview)

    def get_all_objects(self):
        return super(TreeControllerMixin, self).get_all_objects(self.view.treeview)

    def select_object(self, obj, path=None, unselect_all=True):
        tv = self.view.treeview
        sm = tv.selectionModel()
        if sm is None:
            return
        if unselect_all:
            sm.clearSelection()
        if obj is not None:
            if hasattr(self.treemodel, 'get_index_for_object'):
                idx = self.treemodel.get_index_for_object(obj)
                if idx.isValid():
                    sm.select(idx, QItemSelectionModel.Select | QItemSelectionModel.Rows)
        elif path is not None:
            idx = self.treemodel.index(path, 0)
            if idx.isValid():
                sm.select(idx, QItemSelectionModel.Select | QItemSelectionModel.Rows)

    def select_objects(self, objs):
        for obj in objs: self.select_object(obj, unselect_all=False)

    def add_object(self, new_object):
        if new_object is not None:
            index = self.get_selected_index()
            if index is not None:
                self.treemodel_data.insert(index + 1, new_object)
            else:
                self.treemodel_data.append(new_object)

    # ------------------------------------------------------------
    #      Signal handlers
    # ------------------------------------------------------------

    def on_item_removed(self, parent=None, first=None, last=None):
        self.select_object(None, unselect_all=True)

    def on_item_inserted(self, parent=None, first=None, last=None):
        self.select_object(None, path=first, unselect_all=True)

    def objects_tv_selection_changed(self, selected=None, deselected=None):
        obj = self.get_selected_object()
        objs = self.get_selected_objects()
        self.view.set_selection_state(len(objs) if objs is not None else None)
        if self._edit_controller == None or obj != self._edit_controller.model:
            self.edit_object(obj)

    def on_load_object_clicked(self, event):
        raise NotImplementedError

    def on_save_object_clicked(self, event):
        raise NotImplementedError

    def create_new_object_proxy(self):
        raise NotImplementedError

    def on_add_object_clicked(self, event):
        new_object = self.create_new_object_proxy()
        if new_object:
            self.add_object(new_object)
            self.select_object(new_object)
        return True

    @contextmanager
    def _multi_operation_context(self):
        """
            This method should be called as a context manager (with self._multi_...)
            anytime more then one object is changed at the same time.
            Default implementation does not do anything, but this can be used
            to e.g. hold signals from firing until all objects have changed.
        """
        yield # default implementation doesn't do anything.

    def on_del_object_clicked(self, event, del_callback=None, callback=None):
        tv = self.view.treeview
        sm = tv.selectionModel()
        if sm is not None and sm.selectedIndexes():
            def delete_objects(dialog):
                with self._multi_operation_context():
                    for obj in self.get_selected_objects():
                        if callable(del_callback):
                            del_callback(obj)
                        else:
                            self.treemodel_data.remove(obj)
                        if callable(callback): callback(obj)
                    self.edit_object(None)
            parent = self.view.get_top_widget()
            DialogFactory.get_confirmation_dialog(
                message=self.delete_msg, parent=parent
            ).run(delete_objects)


class ObjectListStoreController(DialogController, TreeControllerMixin):
    """
        A stand-alone, regular ObjectListStore controller (left pane with objects and right pane with object properties)
    """
    title = "Edit Dialog"
    auto_adapt = False

    def __init__(self, *args, **kwargs):
        self.title = not_none(kwargs.pop("title", None), self.title)
        super(ObjectListStoreController, self).__init__(*args, **kwargs)

    def register_view(self, view):
        super(ObjectListStoreController, self).register_view(view)
        view.set_title(self.title)

    @DialogController.model.setter
    def _set_model(self, model):
        super(ObjectListStoreController, self)._set_model(model)
        if self.view is not None:
            self._update_treemodel_property()

    def register_adapters(self):
        TreeControllerMixin.register_adapters(self)


class ChildObjectListStoreController(BaseController, TreeControllerMixin):
    """
        An embeddable, regular ObjectListStore controller (left pane with objects and right pane with object properties)
    """
    auto_adapt = False

    @DialogController.model.setter
    def _set_model(self, model):
        super(ObjectListStoreController, self)._set_model(model)
        if self.view is not None:
            self._update_treemodel_property()

    def register_adapters(self):
        TreeControllerMixin.register_adapters(self)

class InlineObjectListStoreController(BaseController, TreeControllerMixin):
    """
        ObjectListStore controller that consists of a single TreeView,
        with import & export and add & delete buttons and an optional combo box
        for type selection
        Subclasses should override the _setup_treeview method to setup their
        columns and edit support.
    """
    treeview = None
    enable_import = False
    enable_export = False
    add_types = list()
    auto_adapt = False

    _edit_dict = None
    def _edit_item(self, item):
        item_type = type(item)
        if self._edit_dict is None:
            # Create a edit dict which keeps track of our controllers
            self._edit_dict = {}

        # If the first time, create the view & controller
        if not item in self._edit_dict:
            for name, tpe, view, ctrl in self.add_types: # @UnusedVariable
                if tpe == item_type:
                    vw = view()
                    ctrl = ctrl(model=item, view=vw, parent=self)
                    self._edit_dict[item] = (vw, ctrl)
                    break
        # Re-use previously created controllers
        vw, ctrl = self._edit_dict[item]
        vw.present()


    def _setup_combo_type(self, combo):
        if self.add_types:
            combo.clear()
            for name, type_, view, ctrl in self.add_types:
                combo.addItem(name, userData=(type_, view, ctrl))

            def on_changed(idx):
                if 0 <= idx < combo.count():
                    data = combo.itemData(idx)
                    if data is not None:
                        self.add_type = data[0]

            combo.currentIndexChanged.connect(on_changed)
            if combo.count() > 0:
                combo.setCurrentIndex(0)
                on_changed(0)
            combo.setVisible(True)
            combo.show()

    def _setup_treeview(self, tv, model):
        raise NotImplementedError

    def __init__(self, *args, **kwargs):
        self.enable_import = kwargs.pop("enable_import", self.enable_import)
        self.enable_export = kwargs.pop("enable_export", self.enable_export)
        super(InlineObjectListStoreController, self).__init__(*args, **kwargs)

    @BaseController.model.setter
    def _set_model(self, model):
        super(ObjectListStoreController, self)._set_model(model)
        if self.view is not None:
            self._update_treemodel_property()

    def register_adapters(self):
        if self.treemodel is not None:
            self.treeview = self.view.treeview
            sm = self.treeview.selectionModel()
            if sm is not None:
                sm.currentChanged.connect(
                    lambda cur, prev: self.on_treeview_cursor_changed(self.treeview, self.treemodel)
                )
            self._setup_treeview(self.treeview, self.treemodel)
            self.type_combobox = self.view.type_combobox_widget
            self._setup_combo_type(self.type_combobox)
            self.update_sensitivities()
        return

    def update_sensitivities(self):
        self.view.del_item_widget.setEnabled(
            self.treeview is not None and self.treeview.currentIndex().isValid()
        )
        self.view.add_item_widget.setEnabled(self.treemodel is not None)
        self.view.export_items_widget.setVisible(self.enable_export)
        self.view.export_items_widget.setEnabled(
            self.treemodel_data is not None and len(self.treemodel_data) > 0
        )
        self.view.import_items_widget.setVisible(self.enable_import)

    def get_selected_object(self):
        return TreeViewMixin.get_selected_object(self, self.treeview)

    def get_selected_objects(self):
        return TreeViewMixin.get_selected_objects(self, self.treeview)

    def get_all_objects(self):
        return TreeViewMixin.get_all_objects(self, self.treeview)

    def select_object(self, obj, path=None, unselect_all=True):
        if self.treeview is None:
            return
        sm = self.treeview.selectionModel()
        if sm is None:
            return
        if unselect_all:
            sm.clearSelection()
        if obj is not None and hasattr(self.treemodel, 'get_index_for_object'):
            idx = self.treemodel.get_index_for_object(obj)
            if idx.isValid():
                sm.select(idx, QItemSelectionModel.Select | QItemSelectionModel.Rows)
        elif path is not None:
            idx = self.treemodel.index(path, 0)
            if idx.isValid():
                sm.select(idx, QItemSelectionModel.Select | QItemSelectionModel.Rows)

    def create_new_object_proxy(self):
        raise NotImplementedError

    def edit_object(self, obj):
        pass

    # ------------------------------------------------------------
    #      Signal handlers
    # ------------------------------------------------------------
    def on_treeview_cursor_changed(self, widget, model):
        self.update_sensitivities()

    def on_item_cell_edited(self, index, new_text, model, col):
        if hasattr(model, 'set_value') and hasattr(model, 'convert'):
            model.set_value(index, col, model.convert(col, new_text))

    pass # end of class
