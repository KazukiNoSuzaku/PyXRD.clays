# coding=UTF-8
# ex:ts=4:sw=4:et=on

# Copyright (c) 2013, Mathijs Dumon
# All rights reserved.
# Complete license can be found in the LICENSE file.

import logging
logger = logging.getLogger(__name__)

from pkg_resources import resource_filename  # @UnresolvedImport

from PySide6.QtWidgets import (
    QWidget, QLabel, QLineEdit, QScrollArea,
    QVBoxLayout, QGridLayout,
)
from PySide6.QtCore import Qt

from mvc.view import View
from mvc.adapters.qt_support.widgets import QtScaleEntry

from pyxrd.data import settings
from pyxrd.generic.mathtext_support import get_string_safe


# ---------------------------------------------------------------------------
# Helper: replace single child of a plain QWidget or QScrollArea
# ---------------------------------------------------------------------------
def _replace_child(container, new_child):
    """
    Remove any existing child from *container* and install *new_child*.
    Handles QScrollArea (setWidget) and plain QWidget with a layout.
    """
    if isinstance(container, QScrollArea):
        container.setWidget(new_child)
    else:
        layout = container.layout()
        if layout is None:
            layout = QVBoxLayout(container)
            layout.setContentsMargins(0, 0, 0, 0)
        while layout.count():
            item = layout.takeAt(0)
            w = item.widget()
            if w is not None:
                w.setParent(None)
        layout.addWidget(new_child)
    new_child.show()
    return new_child


class BaseView(View):
    """
    Basic view providing some common code.
    """
    builder = ""
    modal = False
    resizable = True
    widget_format = "%s"
    container_format = "container_%s"

    current_layout_state = "FULL"
    layout_state_actions = {
        'FULL': ['show::full_mode_only'],
        'VIEWER': ['hide::full_mode_only'],
    }
    widget_groups = {}

    def __init__(self, *args, **kwargs):
        super(BaseView, self).__init__(*args, **kwargs)
        self.parent = kwargs.get("parent", None)
        top = self.get_toplevel()
        if top is not None:
            if hasattr(top, 'setModal'):
                top.setModal(self.modal)
        if self.parent:
            self.set_layout_mode(self.parent.current_layout_state)

    def create_mathtext_widget(self, text, fallback_text=""):
        try:
            from pyxrd.generic.mathtext_support import create_image_from_mathtext
            widget = create_image_from_mathtext(text)
        except Exception:
            if fallback_text:
                text = fallback_text
            widget = QLabel(text)
            widget.setAlignment(Qt.AlignCenter)
        return widget

    def _get_widget_container(self, prop):
        return self[self.container_format % prop.label]

    def _add_widget_to_container(self, widget, container):
        if container is not None:
            _replace_child(container, widget)
        else:
            widget.show()
        return widget

    def add_widget(self, prop, *args, **kwargs):
        method = {
            str: self.add_entry_widget,
            float: self.add_scale_widget,
        }.get(prop.data_type, None)
        if method is not None:
            return method(prop, *args, **kwargs)

    def add_scale_widget(self, prop, enforce_range=True):
        inp = QtScaleEntry(prop.minimum, prop.maximum, enforce_range=enforce_range)
        inp.setToolTip(prop.title)
        self[self.widget_format % prop.label] = inp
        return self._add_widget_to_container(inp, self._get_widget_container(prop))

    def add_entry_widget(self, prop):
        inp = QLineEdit()
        inp.setToolTip(prop.title)
        self[self.widget_format % prop.label] = inp
        return self._add_widget_to_container(inp, self._get_widget_container(prop))

    def create_input_table(self, table, props, num_columns=1, widget_callbacks=[]):
        """
        Places widgets (returned by widget_callbacks) in a QGridLayout on
        *table* for each property in *props*.
        """
        num_props = len(props)
        column_width = len(widget_callbacks)
        widgets = [[None for _ in range(column_width)] for _ in range(num_props)]

        # Get or (re)create the grid layout on *table*
        layout = table.layout()
        if not isinstance(layout, QGridLayout):
            if layout is not None:
                while layout.count():
                    item = layout.takeAt(0)
                    if item.widget():
                        item.widget().setParent(None)
            layout = QGridLayout(table)
            layout.setContentsMargins(2, 2, 2, 2)
            layout.setHorizontalSpacing(4)
            layout.setVerticalSpacing(4)

        for i, prop in enumerate(props):
            column_index = (i % num_columns) * column_width
            for widget_index in range(column_width):
                widget = widget_callbacks[widget_index](prop)
                widgets[i][widget_index] = widget
                col_offset = column_index + widget_index
                row_offset = int(i / num_columns)
                layout.addWidget(widget, row_offset, col_offset)
        return widgets

    def set_layout_mode(self, state):
        self.current_layout_state = state
        for action in self.layout_state_actions.get(state, []):
            parts = tuple(action.split("::", 1))
            command, group_name = parts
            if group_name != "all":
                widget_names = self.widget_groups.get(group_name, [])
                widgets = [self[name] for name in widget_names]
            else:
                widgets = self._builder.get_objects() if self._builder else []

            visible = (command == "show")
            if command not in ("show", "hide"):
                raise ValueError("Unknown layout state command `%s`!" % command)
            for widget in widgets:
                if widget is not None:
                    try:
                        widget.setVisible(visible)
                    except AttributeError:
                        pass

    def show_all(self, *args, **kwargs):
        self.show(*args, **kwargs)

    def present(self):
        toplevel = self.get_toplevel()
        if toplevel is not None:
            if hasattr(toplevel, 'setModal'):
                toplevel.setModal(self.modal)
            toplevel.show()
            toplevel.raise_()
            toplevel.activateWindow()
        self.show()

    def get_toplevel(self):
        for w in [self.top] + list(self):
            try:
                widget = self[w]
                if widget is not None:
                    return widget.window()
            except AttributeError:
                pass
        return None


class TitleView(BaseView):
    """
    Mix-in that provides title support for views.
    """
    title = None

    def __init__(self, *args, **kwargs):
        super(TitleView, self).__init__(*args, **kwargs)
        if self.title is not None:
            self.set_title(self.title)

    def set_title(self, title):
        self.title = title
        top = self.get_toplevel()
        if top is not None:
            top.setWindowTitle(title)

    pass  # end of class


class FormattedTitleView(TitleView):
    """
    Mix-in that provides formatted title support for views.
    """
    title_format = "%s"
    title = ""

    def set_title(self, title, *args, **kwargs):
        self.title = title
        top = self.get_toplevel()
        if top is not None:
            top.setWindowTitle(self.title_format % self.title)

    pass  # end of class


class HasChildView(object):
    """
    Mixin that provides a function to add child views to containers.
    """
    def _add_child_view(self, new_child, container):
        return _replace_child(container, new_child)

    pass  # end of class


class DialogView(HasChildView, TitleView):
    """
    Generalised view for editing stuff with an OK button.
    """
    builder = resource_filename(__name__, "ui/edit_dialog.ui")
    top = "window_edit_dialog"
    container_widget = "edit_child_box"

    subview_builder = ""
    subview_toplevel = None

    def __init__(self, container_widget=None, subview_builder=None,
                 subview_toplevel=None, *args, **kwargs):
        self.container_widget = container_widget or self.container_widget
        self.subview_builder = subview_builder or self.subview_builder
        self.subview_toplevel = subview_toplevel or self.subview_toplevel
        super(DialogView, self).__init__(*args, **kwargs)
        if self.subview_builder:
            self._builder.add_from_file(self.subview_builder)
        if self.subview_toplevel:
            self._add_child_view(
                self[self.subview_toplevel],
                self[self.container_widget]
            )
        return


class ObjectListStoreViewMixin(HasChildView):
    edit_view = None
    edit_view_container = "vwp_edit_object"

    extra_widget_builder = None
    extra_widget_toplevel = ""

    treeview_widget = "edit_objects_treeview"

    @property
    def treeview(self):
        return self[self.treeview_widget]

    @property
    def load_label(self):
        return self["button_load_object"].text()

    @load_label.setter
    def load_label(self, value):
        self["button_load_object"].setText(value)

    @property
    def save_label(self):
        return self["button_save_object"].text()

    @save_label.setter
    def save_label(self, value):
        self["button_save_object"].setText(value)

    @property
    def extra_widget(self):
        box = self["extra_box"]
        if box is None:
            return None
        layout = box.layout()
        if layout and layout.count():
            return layout.itemAt(0).widget()
        return None

    @extra_widget.setter
    def extra_widget(self, widget):
        box = self["extra_box"]
        if box is None:
            return
        layout = box.layout()
        if layout is None:
            layout = QVBoxLayout(box)
            layout.setContentsMargins(0, 0, 0, 0)
        while layout.count():
            item = layout.takeAt(0)
            if item.widget():
                item.widget().setParent(None)
        if widget is not None:
            layout.addWidget(widget)

    @property
    def none_view(self):
        return NoneView()

    def set_selection_state(self, value):
        """
        Sets the state of the view based on number of selected objects.
        value is None (nothing selected) or a count.
        """
        self["button_del_object"].setEnabled(value is not None)
        self["button_save_object"].setEnabled(value is not None)

    def __init__(self, edit_view_container=None, display_buttons=True,
                 load_label=None, save_label=None, **kwargs):
        self.edit_view_container = edit_view_container or self.edit_view_container
        if load_label is not None:
            self.load_label = load_label
        if save_label is not None:
            self.save_label = save_label

        if not display_buttons:
            widget = self["table_data"]
            if widget is not None:
                if widget.parent() and widget.parent().layout():
                    widget.parent().layout().removeWidget(widget)
                widget.setParent(None)

        self.extra_widget_box = self["extra_box"]
        if self.extra_widget_builder is not None:
            self._builder.add_from_file(self.extra_widget_builder)
            self.extra_widget = self._builder.get_object(self.extra_widget_toplevel)
        return

    def set_edit_view(self, view):
        self.edit_view = view
        self.child_view = view.get_top_widget()
        container = self[self.edit_view_container]
        self._add_child_view(self.child_view, container)
        if isinstance(container, QScrollArea):
            hint = self.child_view.sizeHint()
            if hint.width() > 0:
                container.setMinimumWidth(hint.width() + 20)
        return self.edit_view


class ObjectListStoreView(ObjectListStoreViewMixin, DialogView):
    """
    Generalised view for editing objects inside an ObjectListStore
    — Standalone version (inside a DialogView).
    """
    subview_builder = resource_filename(__name__, "ui/object_store.ui")
    subview_toplevel = "edit_object_store"

    def __init__(self, edit_view_container=None, display_buttons=True,
                 load_label=None, save_label=None, **kwargs):
        DialogView.__init__(self, **kwargs)
        ObjectListStoreViewMixin.__init__(
            self,
            edit_view_container=edit_view_container,
            display_buttons=display_buttons,
            load_label=load_label,
            save_label=save_label,
            **kwargs
        )


class ChildObjectListStoreView(ObjectListStoreViewMixin, BaseView):
    """
    Generalised view for editing objects inside an ObjectListStore
    — Child version (to be embedded by a controller).
    """
    edit_view_container = "frame_object_param"

    builder = resource_filename(__name__, "ui/object_store.ui")
    top = "edit_object_store"

    def __init__(self, edit_view_container=None, display_buttons=True,
                 load_label=None, save_label=None, **kwargs):
        BaseView.__init__(self, **kwargs)
        ObjectListStoreViewMixin.__init__(
            self,
            edit_view_container=edit_view_container,
            display_buttons=display_buttons,
            load_label=load_label,
            save_label=save_label,
            **kwargs
        )
        frm = self["frm_objects_tv"]
        if frm is not None:
            frm.setMinimumSize(150, 150)


class InlineObjectListStoreView(BaseView):
    builder = resource_filename(__name__, "ui/inline_ols.ui")
    top = "edit_item"

    @property
    def treeview(self):
        return self['tvw_items']

    @property
    def del_item_widget(self):
        return self['btn_del_item']

    @property
    def add_item_widget(self):
        return self['btn_add_item']

    @property
    def export_items_widget(self):
        return self['btn_export_item']

    @property
    def import_items_widget(self):
        return self['btn_import_item']

    @property
    def type_combobox_widget(self):
        return self['cmb_add_type']


class NoneView(BaseView):
    builder = resource_filename(__name__, "ui/none.ui")
    top = "lbl_caption"
    caption_widget = "lbl_caption"

    def __init__(self, label=None, **kwargs):
        BaseView.__init__(self, **kwargs)
        self._label = self[self.caption_widget]
        if label is not None:
            self.label = label

    _label = None

    @property
    def label(self):
        if self._label is not None:
            return self._label.text()
        return ""

    @label.setter
    def label(self, value):
        if self._label is not None:
            self._label.setText(value)
