# coding=UTF-8
# ex:ts=4:sw=4:et=on

# Copyright (c) 2013, Mathijs Dumon
# All rights reserved.
# Complete license can be found in the LICENSE file.

import os as _os
_resource_filename = lambda path: _os.path.normpath(
    _os.path.join(_os.path.dirname(_os.path.abspath(__file__)), path))
resource_filename = lambda _n, path: _resource_filename(path)

import numpy as np

from PySide6.QtWidgets import QCheckBox, QLineEdit, QComboBox, QPushButton, QGridLayout
from PySide6.QtCore import Qt

from pyxrd.generic.views import BaseView
from pyxrd.generic.views.validators import FloatEntryValidator


def _find_model_row(model, obj):
    """Find the row index for the given object in a Qt item model."""
    if obj is None or model is None:
        return -1
    if hasattr(model, "get_index_for_object"):
        idx = model.get_index_for_object(obj)
        if idx.isValid():
            return idx.row()
    for row in range(model.rowCount()):
        qidx = model.index(row, 0)
        if qidx.internalPointer() is obj:
            return row
    return -1


class EditMixtureView(BaseView):
    builder = resource_filename(__name__, "ui/edit_mixture.ui")
    top = "edit_mixture"

    base_width = 4
    base_height = 5

    matrix_widget = "tbl_matrix"
    wrapper_widget = "tbl_wrapper"
    widget_format = "mixture_%s"

    def __init__(self, *args, **kwargs):
        BaseView.__init__(self, *args, **kwargs)

        self.parent.set_title("Edit Mixtures")
        self.matrix = self[self.matrix_widget]
        self.wrapper = self[self.wrapper_widget]

        self.labels = [
            self["lbl_scales"], self["lbl_fractions"], self["lbl_phases"],
            self["lbl_bgshifts"], self["lbl_specimens"],
            self["mixture_auto_scales"], self["mixture_auto_bg"],
        ]

        self._matrix_layout = self.matrix.layout() if self.matrix is not None else None
        if self._matrix_layout is None and self.matrix is not None:
            self._matrix_layout = QGridLayout(self.matrix)
            self._matrix_layout.setContentsMargins(5, 5, 5, 5)
            self._matrix_layout.setSpacing(5)

        self._n_rows = self.base_height
        self._n_cols = self.base_width

        self.reset_view()

    def reset_view(self):
        if self._matrix_layout is not None:
            items_to_remove = []
            for i in range(self._matrix_layout.count()):
                item = self._matrix_layout.itemAt(i)
                if item is not None:
                    w = item.widget()
                    if w is not None and w not in self.labels:
                        items_to_remove.append(w)
            for w in items_to_remove:
                self._matrix_layout.removeWidget(w)
                w.setParent(None)
                w.deleteLater()

        self._n_rows = self.base_height
        self._n_cols = self.base_width

        self.phase_inputs = []
        self.fraction_inputs = []
        self.fraction_checks = []
        self.specimen_combos = []
        self.scale_inputs = []
        self.bgs_inputs = []
        self.phase_combos = np.empty(shape=(0, 0), dtype=object)

    def set_edit_view(self, view):
        self.edit_view = view
        child = view.get_top_widget()
        self._add_child_view(child, self["edit_view_container"])

    def update_all(self, fractions, scales, bgs):
        for i, fraction in enumerate(fractions):
            if i < len(self.fraction_inputs):
                self.fraction_inputs[i].setText(str(fraction))
        for i, scale in enumerate(scales):
            if i < len(self.scale_inputs):
                self.scale_inputs[i].setText(str(scale))
        for i, bg in enumerate(bgs):
            if i < len(self.bgs_inputs):
                self.bgs_inputs[i].setText(str(bg))

    def add_phase_slot(self, phase_store, del_phase_callback, label_callback,
                       check_callback, fraction_callback, combo_callback,
                       label, fraction, phases):
        r = self._n_rows
        c = self._n_cols
        self._n_rows += 1
        layout = self._matrix_layout

        new_phase_del_btn = QPushButton("x")
        new_phase_del_btn.setMaximumWidth(28)
        new_phase_del_btn.clicked.connect(del_phase_callback)
        setattr(new_phase_del_btn, "deleventid", None)
        layout.addWidget(new_phase_del_btn, r, 0)

        new_phase_input = self._get_new_input(label, callback=label_callback)
        self.phase_inputs.append(new_phase_input)
        layout.addWidget(new_phase_input, r, 1)

        new_fraction_check = self._get_new_check(callback=check_callback)
        self.fraction_checks.append(new_fraction_check)
        layout.addWidget(new_fraction_check, r, 2)

        new_fraction_input = self._get_new_input(str(fraction), callback=fraction_callback)
        FloatEntryValidator(new_fraction_input)
        self.fraction_inputs.append(new_fraction_input)
        layout.addWidget(new_fraction_input, r, 3)

        n_specimens = c - self.base_width
        n_new_phases = r + 1 - self.base_height
        if n_specimens > 0:
            self.phase_combos.resize((n_specimens, n_new_phases))
            for col in range(n_specimens):
                mcol = r - self.base_height  # new phase index
                mrow = col                   # specimen index
                default = phases[mrow, mcol] if phases is not None and phases.shape[0] > mrow and phases.shape[1] > mcol else None
                self._add_new_phase_combo(phase_store, phase_store.c_name, default, mrow, mcol, combo_callback)

        if self.matrix is not None:
            self.matrix.updateGeometry()

    def add_specimen_slot(self, phase_store, specimen_store, del_specimen_callback,
                          scale_callback, bgs_callback, specimen_callback, combo_callback,
                          scale, bgs, specimen, phases):
        r = self._n_rows
        c = self._n_cols
        self._n_cols += 1
        layout = self._matrix_layout

        new_specimen_del_btn = QPushButton("x")
        new_specimen_del_btn.setMaximumWidth(28)
        new_specimen_del_btn.clicked.connect(del_specimen_callback)
        setattr(new_specimen_del_btn, "deleventid", None)
        layout.addWidget(new_specimen_del_btn, 0, c)

        new_specimen_combo = self._get_new_combo(specimen_store, specimen_store.c_name, default=specimen, callback=specimen_callback)
        self.specimen_combos.append(new_specimen_combo)
        layout.addWidget(new_specimen_combo, 1, c)

        new_bgs_input = self._get_new_input(str(bgs), callback=bgs_callback)
        FloatEntryValidator(new_bgs_input)
        self.bgs_inputs.append(new_bgs_input)
        layout.addWidget(new_bgs_input, 2, c)

        new_scale_input = self._get_new_input(str(scale), callback=scale_callback)
        FloatEntryValidator(new_scale_input)
        self.scale_inputs.append(new_scale_input)
        layout.addWidget(new_scale_input, 3, c)

        n_new_specimens = c + 1 - self.base_width
        n_phases = r - self.base_height
        if n_phases > 0:
            self.phase_combos.resize((n_new_specimens, n_phases))
            for row in range(n_phases):
                mcol = row                   # phase index
                mrow = c - self.base_width   # new specimen index
                default = phases[mrow, mcol] if phases is not None and phases.shape[0] > mrow and phases.shape[1] > mcol else None
                self._add_new_phase_combo(phase_store, phase_store.c_name, default, mrow, mcol, combo_callback)

        if self.matrix is not None:
            self.matrix.updateGeometry()

    def _get_new_check(self, callback=None):
        new_check = QCheckBox()
        new_check.setChecked(True)
        new_check.setToolTip("Tick this box if you want to include this fraction in optimizations and refinements")
        if callback is not None:
            new_check.toggled.connect(lambda checked, w=new_check, cb=callback: cb(w))
        return new_check

    def _get_new_input(self, text="", width=7, callback=None):
        new_input = QLineEdit()
        new_input.setText(text)
        new_input.setAlignment(Qt.AlignLeft)
        new_input.setMaximumWidth(width * 10)
        if callback is not None:
            new_input.textChanged.connect(lambda text, w=new_input, cb=callback: cb(w))
        return new_input

    def _add_new_phase_combo(self, model, text_column, default, r, c, callback):
        """
        Creates a new phase slot combo box at grid position (specimen_idx=r, phase_idx=c).
        Attaches to column=base_width+r, row=base_height+c in the layout.
        """
        new_phase_combo = self._get_new_combo(model, text_column, default, callback, r, c)
        self.phase_combos[r, c] = new_phase_combo
        self._matrix_layout.addWidget(new_phase_combo, self.base_height + c, self.base_width + r)

    def _get_new_combo(self, model, text_column, default=None, callback=None, *args):
        combobox = QComboBox()
        combobox.setMinimumWidth(75)
        if model is not None:
            combobox.setModel(model)
            combobox.setModelColumn(text_column)
            if default is not None:
                row = _find_model_row(model, default)
                if row >= 0:
                    combobox.setCurrentIndex(row)
        if callback is not None:
            def on_changed(_idx, _cb=callback, _cmb=combobox, _args=args):
                _cb(_cmb, *_args)
            combobox.currentIndexChanged.connect(on_changed)
        return combobox

    pass  # end of class
